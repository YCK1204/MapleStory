// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CHARACTER_H_
#define FLATBUFFERS_GENERATED_CHARACTER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct CharacterAbility;
struct CharacterAbilityBuilder;

struct CharacterInfo;
struct CharacterInfoBuilder;

struct CharacterInfoDetail;
struct CharacterInfoDetailBuilder;

struct CharacterAbility FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CharacterAbilityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STR = 4,
    VT_DEX = 6,
    VT_INT = 8,
    VT_LUK = 10
  };
  uint16_t STR() const {
    return GetField<uint16_t>(VT_STR, 0);
  }
  uint16_t DEX() const {
    return GetField<uint16_t>(VT_DEX, 0);
  }
  uint16_t INT() const {
    return GetField<uint16_t>(VT_INT, 0);
  }
  uint16_t LUK() const {
    return GetField<uint16_t>(VT_LUK, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STR, 2) &&
           VerifyField<uint16_t>(verifier, VT_DEX, 2) &&
           VerifyField<uint16_t>(verifier, VT_INT, 2) &&
           VerifyField<uint16_t>(verifier, VT_LUK, 2) &&
           verifier.EndTable();
  }
};

struct CharacterAbilityBuilder {
  typedef CharacterAbility Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_STR(uint16_t STR) {
    fbb_.AddElement<uint16_t>(CharacterAbility::VT_STR, STR, 0);
  }
  void add_DEX(uint16_t DEX) {
    fbb_.AddElement<uint16_t>(CharacterAbility::VT_DEX, DEX, 0);
  }
  void add_INT(uint16_t INT) {
    fbb_.AddElement<uint16_t>(CharacterAbility::VT_INT, INT, 0);
  }
  void add_LUK(uint16_t LUK) {
    fbb_.AddElement<uint16_t>(CharacterAbility::VT_LUK, LUK, 0);
  }
  explicit CharacterAbilityBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CharacterAbility> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CharacterAbility>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CharacterAbility> CreateCharacterAbility(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t STR = 0,
    uint16_t DEX = 0,
    uint16_t INT = 0,
    uint16_t LUK = 0) {
  CharacterAbilityBuilder builder_(_fbb);
  builder_.add_LUK(LUK);
  builder_.add_INT(INT);
  builder_.add_DEX(DEX);
  builder_.add_STR(STR);
  return builder_.Finish();
}

struct CharacterInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CharacterInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHAR_ID = 4,
    VT_CHAR_TYPE = 6,
    VT_LEVEL = 8,
    VT_NAME = 10,
    VT_ABILITY = 12
  };
  uint64_t char_id() const {
    return GetField<uint64_t>(VT_CHAR_ID, 0);
  }
  uint8_t char_type() const {
    return GetField<uint8_t>(VT_CHAR_TYPE, 0);
  }
  uint16_t level() const {
    return GetField<uint16_t>(VT_LEVEL, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const CharacterAbility *ability() const {
    return GetPointer<const CharacterAbility *>(VT_ABILITY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CHAR_ID, 8) &&
           VerifyField<uint8_t>(verifier, VT_CHAR_TYPE, 1) &&
           VerifyField<uint16_t>(verifier, VT_LEVEL, 2) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ABILITY) &&
           verifier.VerifyTable(ability()) &&
           verifier.EndTable();
  }
};

struct CharacterInfoBuilder {
  typedef CharacterInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_char_id(uint64_t char_id) {
    fbb_.AddElement<uint64_t>(CharacterInfo::VT_CHAR_ID, char_id, 0);
  }
  void add_char_type(uint8_t char_type) {
    fbb_.AddElement<uint8_t>(CharacterInfo::VT_CHAR_TYPE, char_type, 0);
  }
  void add_level(uint16_t level) {
    fbb_.AddElement<uint16_t>(CharacterInfo::VT_LEVEL, level, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(CharacterInfo::VT_NAME, name);
  }
  void add_ability(::flatbuffers::Offset<CharacterAbility> ability) {
    fbb_.AddOffset(CharacterInfo::VT_ABILITY, ability);
  }
  explicit CharacterInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CharacterInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CharacterInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CharacterInfo> CreateCharacterInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t char_id = 0,
    uint8_t char_type = 0,
    uint16_t level = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<CharacterAbility> ability = 0) {
  CharacterInfoBuilder builder_(_fbb);
  builder_.add_char_id(char_id);
  builder_.add_ability(ability);
  builder_.add_name(name);
  builder_.add_level(level);
  builder_.add_char_type(char_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CharacterInfo> CreateCharacterInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t char_id = 0,
    uint8_t char_type = 0,
    uint16_t level = 0,
    const char *name = nullptr,
    ::flatbuffers::Offset<CharacterAbility> ability = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateCharacterInfo(
      _fbb,
      char_id,
      char_type,
      level,
      name__,
      ability);
}

struct CharacterInfoDetail FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CharacterInfoDetailBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PREV_INFO = 4,
    VT_LAST_POS = 6,
    VT_HP = 8,
    VT_MP = 10,
    VT_EXP = 12
  };
  const CharacterInfo *prev_info() const {
    return GetPointer<const CharacterInfo *>(VT_PREV_INFO);
  }
  int32_t last_pos() const {
    return GetField<int32_t>(VT_LAST_POS, 0);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PREV_INFO) &&
           verifier.VerifyTable(prev_info()) &&
           VerifyField<int32_t>(verifier, VT_LAST_POS, 4) &&
           VerifyField<int32_t>(verifier, VT_HP, 4) &&
           VerifyField<int32_t>(verifier, VT_MP, 4) &&
           VerifyField<int32_t>(verifier, VT_EXP, 4) &&
           verifier.EndTable();
  }
};

struct CharacterInfoDetailBuilder {
  typedef CharacterInfoDetail Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_prev_info(::flatbuffers::Offset<CharacterInfo> prev_info) {
    fbb_.AddOffset(CharacterInfoDetail::VT_PREV_INFO, prev_info);
  }
  void add_last_pos(int32_t last_pos) {
    fbb_.AddElement<int32_t>(CharacterInfoDetail::VT_LAST_POS, last_pos, 0);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(CharacterInfoDetail::VT_HP, hp, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(CharacterInfoDetail::VT_MP, mp, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(CharacterInfoDetail::VT_EXP, exp, 0);
  }
  explicit CharacterInfoDetailBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CharacterInfoDetail> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CharacterInfoDetail>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CharacterInfoDetail> CreateCharacterInfoDetail(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<CharacterInfo> prev_info = 0,
    int32_t last_pos = 0,
    int32_t hp = 0,
    int32_t mp = 0,
    int32_t exp = 0) {
  CharacterInfoDetailBuilder builder_(_fbb);
  builder_.add_exp(exp);
  builder_.add_mp(mp);
  builder_.add_hp(hp);
  builder_.add_last_pos(last_pos);
  builder_.add_prev_info(prev_info);
  return builder_.Finish();
}

#endif  // FLATBUFFERS_GENERATED_CHARACTER_H_
