// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WORLDSELECT_H_
#define FLATBUFFERS_GENERATED_WORLDSELECT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct C_EnterChannel;
struct C_EnterChannelBuilder;

struct SC_EnterChannel;
struct SC_EnterChannelBuilder;

struct ChannelInfo;

struct ServerInfo;
struct ServerInfoBuilder;

struct C_ChannelInfo;
struct C_ChannelInfoBuilder;

struct SC_ChannelInfo;
struct SC_ChannelInfoBuilder;

enum EnterChannelError : uint8_t {
  EnterChannelError_SUCCESS = 0,
  EnterChannelError_FULL = 1,
  EnterChannelError_UNKNOWN = 2,
  EnterChannelError_MIN = EnterChannelError_SUCCESS,
  EnterChannelError_MAX = EnterChannelError_UNKNOWN
};

inline const EnterChannelError (&EnumValuesEnterChannelError())[3] {
  static const EnterChannelError values[] = {
    EnterChannelError_SUCCESS,
    EnterChannelError_FULL,
    EnterChannelError_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesEnterChannelError() {
  static const char * const names[4] = {
    "SUCCESS",
    "FULL",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameEnterChannelError(EnterChannelError e) {
  if (::flatbuffers::IsOutRange(e, EnterChannelError_SUCCESS, EnterChannelError_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEnterChannelError()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) ChannelInfo FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t user_count_;
  uint8_t id_;
  int8_t padding0__;

 public:
  ChannelInfo()
      : user_count_(0),
        id_(0),
        padding0__(0) {
    (void)padding0__;
  }
  ChannelInfo(uint16_t _user_count, uint8_t _id)
      : user_count_(::flatbuffers::EndianScalar(_user_count)),
        id_(::flatbuffers::EndianScalar(_id)),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t user_count() const {
    return ::flatbuffers::EndianScalar(user_count_);
  }
  uint8_t id() const {
    return ::flatbuffers::EndianScalar(id_);
  }
};
FLATBUFFERS_STRUCT_END(ChannelInfo, 4);

struct C_EnterChannel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C_EnterChannelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVER_INDEX = 4,
    VT_CHANNEL_INDEX = 6
  };
  uint8_t server_index() const {
    return GetField<uint8_t>(VT_SERVER_INDEX, 0);
  }
  uint8_t channel_index() const {
    return GetField<uint8_t>(VT_CHANNEL_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SERVER_INDEX, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHANNEL_INDEX, 1) &&
           verifier.EndTable();
  }
};

struct C_EnterChannelBuilder {
  typedef C_EnterChannel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_server_index(uint8_t server_index) {
    fbb_.AddElement<uint8_t>(C_EnterChannel::VT_SERVER_INDEX, server_index, 0);
  }
  void add_channel_index(uint8_t channel_index) {
    fbb_.AddElement<uint8_t>(C_EnterChannel::VT_CHANNEL_INDEX, channel_index, 0);
  }
  explicit C_EnterChannelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C_EnterChannel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C_EnterChannel>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C_EnterChannel> CreateC_EnterChannel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t server_index = 0,
    uint8_t channel_index = 0) {
  C_EnterChannelBuilder builder_(_fbb);
  builder_.add_channel_index(channel_index);
  builder_.add_server_index(server_index);
  return builder_.Finish();
}

struct SC_EnterChannel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_EnterChannelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OK = 4
  };
  EnterChannelError ok() const {
    return static_cast<EnterChannelError>(GetField<uint8_t>(VT_OK, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OK, 1) &&
           verifier.EndTable();
  }
};

struct SC_EnterChannelBuilder {
  typedef SC_EnterChannel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ok(EnterChannelError ok) {
    fbb_.AddElement<uint8_t>(SC_EnterChannel::VT_OK, static_cast<uint8_t>(ok), 0);
  }
  explicit SC_EnterChannelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_EnterChannel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_EnterChannel>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_EnterChannel> CreateSC_EnterChannel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    EnterChannelError ok = EnterChannelError_SUCCESS) {
  SC_EnterChannelBuilder builder_(_fbb);
  builder_.add_ok(ok);
  return builder_.Finish();
}

struct ServerInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ServerInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ID = 6,
    VT_MAX_USER_COUNT = 8,
    VT_CHANNELS = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint8_t id() const {
    return GetField<uint8_t>(VT_ID, 0);
  }
  uint16_t max_user_count() const {
    return GetField<uint16_t>(VT_MAX_USER_COUNT, 0);
  }
  const ::flatbuffers::Vector<const ChannelInfo *> *channels() const {
    return GetPointer<const ::flatbuffers::Vector<const ChannelInfo *> *>(VT_CHANNELS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_ID, 1) &&
           VerifyField<uint16_t>(verifier, VT_MAX_USER_COUNT, 2) &&
           VerifyOffset(verifier, VT_CHANNELS) &&
           verifier.VerifyVector(channels()) &&
           verifier.EndTable();
  }
};

struct ServerInfoBuilder {
  typedef ServerInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ServerInfo::VT_NAME, name);
  }
  void add_id(uint8_t id) {
    fbb_.AddElement<uint8_t>(ServerInfo::VT_ID, id, 0);
  }
  void add_max_user_count(uint16_t max_user_count) {
    fbb_.AddElement<uint16_t>(ServerInfo::VT_MAX_USER_COUNT, max_user_count, 0);
  }
  void add_channels(::flatbuffers::Offset<::flatbuffers::Vector<const ChannelInfo *>> channels) {
    fbb_.AddOffset(ServerInfo::VT_CHANNELS, channels);
  }
  explicit ServerInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ServerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ServerInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ServerInfo> CreateServerInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint8_t id = 0,
    uint16_t max_user_count = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const ChannelInfo *>> channels = 0) {
  ServerInfoBuilder builder_(_fbb);
  builder_.add_channels(channels);
  builder_.add_name(name);
  builder_.add_max_user_count(max_user_count);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ServerInfo> CreateServerInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint8_t id = 0,
    uint16_t max_user_count = 0,
    const std::vector<ChannelInfo> *channels = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto channels__ = channels ? _fbb.CreateVectorOfStructs<ChannelInfo>(*channels) : 0;
  return CreateServerInfo(
      _fbb,
      name__,
      id,
      max_user_count,
      channels__);
}

struct C_ChannelInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef C_ChannelInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVER_ID = 4
  };
  uint8_t server_id() const {
    return GetField<uint8_t>(VT_SERVER_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SERVER_ID, 1) &&
           verifier.EndTable();
  }
};

struct C_ChannelInfoBuilder {
  typedef C_ChannelInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_server_id(uint8_t server_id) {
    fbb_.AddElement<uint8_t>(C_ChannelInfo::VT_SERVER_ID, server_id, 0);
  }
  explicit C_ChannelInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<C_ChannelInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<C_ChannelInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<C_ChannelInfo> CreateC_ChannelInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t server_id = 0) {
  C_ChannelInfoBuilder builder_(_fbb);
  builder_.add_server_id(server_id);
  return builder_.Finish();
}

struct SC_ChannelInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SC_ChannelInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVER_ID = 4,
    VT_CHANNELS = 6
  };
  uint8_t server_id() const {
    return GetField<uint8_t>(VT_SERVER_ID, 0);
  }
  const ::flatbuffers::Vector<const ChannelInfo *> *channels() const {
    return GetPointer<const ::flatbuffers::Vector<const ChannelInfo *> *>(VT_CHANNELS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SERVER_ID, 1) &&
           VerifyOffset(verifier, VT_CHANNELS) &&
           verifier.VerifyVector(channels()) &&
           verifier.EndTable();
  }
};

struct SC_ChannelInfoBuilder {
  typedef SC_ChannelInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_server_id(uint8_t server_id) {
    fbb_.AddElement<uint8_t>(SC_ChannelInfo::VT_SERVER_ID, server_id, 0);
  }
  void add_channels(::flatbuffers::Offset<::flatbuffers::Vector<const ChannelInfo *>> channels) {
    fbb_.AddOffset(SC_ChannelInfo::VT_CHANNELS, channels);
  }
  explicit SC_ChannelInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SC_ChannelInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SC_ChannelInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SC_ChannelInfo> CreateSC_ChannelInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t server_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const ChannelInfo *>> channels = 0) {
  SC_ChannelInfoBuilder builder_(_fbb);
  builder_.add_channels(channels);
  builder_.add_server_id(server_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SC_ChannelInfo> CreateSC_ChannelInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t server_id = 0,
    const std::vector<ChannelInfo> *channels = nullptr) {
  auto channels__ = channels ? _fbb.CreateVectorOfStructs<ChannelInfo>(*channels) : 0;
  return CreateSC_ChannelInfo(
      _fbb,
      server_id,
      channels__);
}

#endif  // FLATBUFFERS_GENERATED_WORLDSELECT_H_
